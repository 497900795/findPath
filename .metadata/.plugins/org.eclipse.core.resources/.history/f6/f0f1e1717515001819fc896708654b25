package findPath;
import java.util.Scanner;

public class FindPath {
	private static int startPoint,startFloor,startBuliding;
	private static int endPoint,endFloor,endBuliding;
	private static int [] minPath;
	private static int minPoint;
	private static int minDist = Integer.MAX_VALUE;
	
	//l->楼号减,r->楼号加,n->不能移动楼号
	private static char transBulidingWay[][][] = {
		//每一维分别为楼、楼层、所在点
		{
			{'l','n','r',},		
			{'l','n','r',},
		},
		
		{
			{'l','n','r',},
		},
	};
	//结束后在新楼的位置
	private static int transBulidingEnd[][][] = {
		//每一维分别为楼、楼层、所在点
		{
			{0,1,2,},			
			{0,1,2,},
		},
		
		{
			{0,1,2,},
		},
	};
	
	//c->能移动楼层,n->不能移动楼层
	private static char transFloorWay[][][] = {
		//每一维分别为楼、楼层、所在点
		{
			{'c','n','n',},		
			{'c','n','n',},	
		},
		
		{
			{'c','n','n',},	
		},
	};
		
	public static void main(String[] args) {
		while(sureBulidingWay() != 'n'){
			int NUM = transBulidingWay[startBuliding][startFloor].length;
			boolean find = false;
			for(int i = 0;i < NUM;i++){
				if(transBulidingWay[startBuliding][startFloor][i] == sureBulidingWay()){
					find = true;
					Dijkstra dij = new Dijkstra (startPoint,i);
					dij.dijkstra();
					minPoint = i;
					if(minDist < dij.getDist(i)){
						minDist = dij.getDist(i);
						minPath = dij.getPath(i);
					}
				}
			}
			
			//对本层能否进行楼间跨越讨论
			if(find){
				resetStartBuilding(minPoint,startFloor,startBuliding);
			}
			else{
				pathForFloor();
			}
			
		}
		
	}
	
	FindPath(){
		System.out.println("输入输入顺序:开始点 层 楼 结束点 层 楼");
		Scanner input=new Scanner(System.in);
		startPoint = input.nextInt();
		startFloor = input.nextInt();
		startBuliding = input.nextInt();
		endPoint = input.nextInt();
		endFloor = input.nextInt();
		endBuliding = input.nextInt();
		input.close();
	}
	
	//point floor buliding
	FindPath(int startP,int startF,int startB,int endP,int endF,int endB){
		startPoint = startP;
		startFloor = startF;
		startBuliding = startB;
		endPoint = endP;
		endFloor = endF;
		endBuliding = endB;
	}
	
	//确定方向，从数组匹配
	public static char sureBulidingWay(){
		if(startBuliding > endBuliding){
			return 'l';
		}
		else if(startBuliding < endBuliding){
			return 'r';
		}
		else{
			return  'n';
		}
	}
	
	public static char sureFloorWay(){
		if(startFloor == endFloor){
			return 'n';
		}
		else{
			return 'c';
		}
	}
	
	//从transBulidingEnd查询开始点(从现实情况考虑，楼层不会变)
	public static void resetStartPoint(int transPoint,int transFloor,int transBuliding){
		startPoint = transBulidingEnd[transBuliding][transFloor][transPoint];
	}
	
	public static void resetStartFloor(int objectFloor){
		startFloor = objectFloor;
	}
	
	//根据transFloorWay决定楼号变化，
	public static void resetStartBuilding(int transPoint,int transFloor,int transBuliding){
		if(transFloorWay[transBuliding][transFloor][transPoint]== 'r'){
			startBuliding++;
			resetStartPoint(transPoint,transFloor,transBuliding);
		}
		else if(transFloorWay[transBuliding][transFloor][transPoint]== 'l'){
			startBuliding--;
			resetStartPoint(transPoint,transFloor,transBuliding);
		}
	}

	public static void pathForFloor(){
		if(sureFloorWay() == 'n'){
			Dijkstra dij = new Dijkstra (startPoint,endPoint);
			dij.dijkstra();
		}
		else{
			int NUM = transFloorWay[startBuliding][startFloor].length;
			for(int i = 0;i < NUM;i++){
				if(transFloorWay[startBuliding][startFloor][startPoint] == sureFloorWay()){
					
				}
			}
		}
	}
}
